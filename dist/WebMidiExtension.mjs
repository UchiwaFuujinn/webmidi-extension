var img$1 = "data:image/png;base64,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";

var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 53 53' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e%3crect id='%e3%82%a2%e3%83%bc%e3%83%88%e3%83%9c%e3%83%bc%e3%83%891' x='0' y='-0' width='52.083' height='52.056' style='fill:none%3b'/%3e%3cclipPath id='_clip1'%3e%3crect x='0' y='-0' width='52.083' height='52.056'/%3e%3c/clipPath%3e%3cg clip-path='url(%23_clip1)'%3e%3cg%3e%3cg%3e%3cpath d='M17.605%2c14.113c1.125%2c0.983 1.582%2c2.148 2.563%2c3.17c2.407%2c2.507 4.811%2c5.102 7.423%2c7.551c4.352%2c4.079 10.045%2c7.577 14.675%2c11.435' style='fill:none%3bstroke:white%3bstroke-width:19.17px%3bstroke-linecap:round%3bstroke-miterlimit:1.5%3b'/%3e%3cpath d='M40.824%2c11.292c-0.914%2c2.03 -3.668%2c3.898 -5.723%2c5.559c-2.684%2c2.171 -5.276%2c4.398 -7.941%2c6.581c-7.278%2c5.958 -12.955%2c12.359 -18.301%2c19.04' style='fill:none%3bstroke:white%3bstroke-width:19.17px%3bstroke-linecap:round%3bstroke-miterlimit:1.5%3b'/%3e%3c/g%3e%3cg%3e%3cpath d='M17.605%2c14.113c1.125%2c0.983 1.582%2c2.148 2.563%2c3.17c2.407%2c2.507 4.811%2c5.102 7.423%2c7.551c4.352%2c4.079 10.045%2c7.577 14.675%2c11.435' style='fill:none%3bstroke:%23f9a83a%3bstroke-width:12.5px%3bstroke-linecap:round%3bstroke-miterlimit:1.5%3b'/%3e%3cpath d='M40.824%2c11.292c-0.914%2c2.03 -3.668%2c3.898 -5.723%2c5.559c-2.684%2c2.171 -5.276%2c4.398 -7.941%2c6.581c-7.278%2c5.958 -12.955%2c12.359 -18.301%2c19.04' style='fill:none%3bstroke:%23f9a83a%3bstroke-width:12.5px%3bstroke-linecap:round%3bstroke-miterlimit:1.5%3b'/%3e%3c/g%3e%3cg%3e%3cpath d='M16.783%2c15.055c0.264%2c0.231 0.482%2c0.475 0.679%2c0.725c0.621%2c0.785 1.078%2c1.612 1.804%2c2.368c1.456%2c1.517 2.91%2c3.065 4.41%2c4.594c0.996%2c1.015 2.012%2c2.021 3.06%2c3.004c1.353%2c1.268 2.831%2c2.481 4.368%2c3.666c3.429%2c2.643 7.152%2c5.143 10.362%2c7.817c0.53%2c0.442 1.319%2c0.37 1.76%2c-0.16c0.442%2c-0.53 0.37%2c-1.319 -0.16%2c-1.76c-3.233%2c-2.694 -6.982%2c-5.215 -10.435%2c-7.877c-1.472%2c-1.135 -2.89%2c-2.296 -4.185%2c-3.51c-1.023%2c-0.959 -2.014%2c-1.941 -2.985%2c-2.931c-1.494%2c-1.522 -2.942%2c-3.064 -4.392%2c-4.574c-0.667%2c-0.695 -1.075%2c-1.465 -1.645%2c-2.187c-0.288%2c-0.365 -0.61%2c-0.72 -0.997%2c-1.058c-0.52%2c-0.454 -1.31%2c-0.4 -1.764%2c0.119c-0.453%2c0.52 -0.4%2c1.31 0.12%2c1.764Z' style='fill:white%3b'/%3e%3cpath d='M39.685%2c10.779c-0.331%2c0.733 -0.963%2c1.428 -1.694%2c2.108c-1.138%2c1.059 -2.52%2c2.058 -3.676%2c2.992l-7.947%2c6.585c-3.596%2c2.944 -6.805%2c5.995 -9.778%2c9.133c-3.104%2c3.276 -5.949%2c6.648 -8.707%2c10.094c-0.431%2c0.539 -0.343%2c1.326 0.195%2c1.757c0.539%2c0.431 1.326%2c0.344 1.757%2c-0.195c2.715%2c-3.392 5.515%2c-6.712 8.57%2c-9.937c2.903%2c-3.064 6.036%2c-6.043 9.547%2c-8.917l7.935%2c-6.576c1.418%2c-1.146 3.155%2c-2.393 4.43%2c-3.716c0.716%2c-0.743 1.293%2c-1.516 1.647%2c-2.301c0.283%2c-0.629 0.003%2c-1.37 -0.626%2c-1.653c-0.629%2c-0.284 -1.37%2c-0.003 -1.653%2c0.626Z' style='fill:white%3b'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

var en = {
	"WebMidiExtension.entry.name": "WebMidi Extension",
	"WebMidiExtension.entry.description": "Description of this extension"
};
var ja = {
	"WebMidiExtension.entry.name": "WebMidi Extension",
	"WebMidiExtension.entry.description": "拡張機能の説明"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"WebMidiExtension.entry.name": "WebMidi Extension",
	"WebMidiExtension.entry.description": "かくちょうきのうのせつめい"
}
};

/**
 * This is an extension for Xcratch.
 */
/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */

var formatMessage$2 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};

var entry = {
  get name() {
    return formatMessage$2({
      id: 'WebMidiExtension.entry.name',
      default: 'WebMidi Extension',
      description: 'name of the extension'
    });
  },

  extensionId: 'WebMidiExtension',
  extensionURL: 'https://githubAccount.github.io/webmidi-extension/dist/WebMidiExtension.mjs',
  collaborator: 'githubAccount',
  iconURL: img$1,
  insetIconURL: img,

  get description() {
    return formatMessage$2({
      defaultMessage: 'an extension for Xcratch',
      description: 'Description for this extension',
      id: 'WebMidiExtension.entry.description'
    });
  },

  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://githubAccount.github.io/webmidi-extension/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$2 = formatter;
  },
  translationMap: translations
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType$1 = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType$1;

/**
 * Types of block
 * @enum {string}
 */
var BlockType$1 = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType$1;

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    classCallCheck(this, Color);
  }

  createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
    /** @type {RGBObject} */

  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }
    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */

  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }

      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }
    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }
    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */

  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }
    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */

  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }
    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */

  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }
    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;

        case 1:
          r = q;
          g = v;
          b = p;
          break;

        case 2:
          r = p;
          g = v;
          b = t;
          break;

        case 3:
          r = p;
          g = q;
          b = v;
          break;

        case 4:
          r = t;
          g = p;
          b = v;
          break;

        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }

      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }
    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */

  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b); // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate

      var h = 0;
      var s = 0;

      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }

      return {
        h: h,
        s: s,
        v: v
      };
    }
    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */

  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);

  return Color;
}();

var color$3 = Color$1;

var Color = color$3;
/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */

var Cast$1 = /*#__PURE__*/function () {
  function Cast() {
    classCallCheck(this, Cast);
  }

  createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }

        return value;
      }

      var n = Number(value);

      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }

      return n;
    }
    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */

  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }

      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        } // All other strings treated as true.


        return true;
      } // Coerce other values and numbers.


      return Boolean(value);
    }
    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */

  }, {
    key: "toString",
    value: function toString(value) {
      return String(value);
    }
    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }
    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;

      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value); // If the color wasn't *actually* a hex color, cast to black

        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }

      return color;
    }
    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */

  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }
    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */

  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);

      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }

      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = String(v1).toLowerCase();
        var s2 = String(v2).toLowerCase();

        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }

        return 0;
      } // Handle the special case of Infinity


      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      } // Compare as numbers.


      return n1 - n2;
    }
    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */

  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        } // True if it's "round" (e.g., 2.0 and 2).


        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }

      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }
    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */

  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }

        if (index === 'last') {
          if (length > 0) {
            return length;
          }

          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }

          return Cast.LIST_INVALID;
        }
      }

      index = Math.floor(Cast.toNumber(index));

      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }

      return index;
    }
  }]);

  return Cast;
}();

var cast = Cast$1;

var web = {exports: {}};

var minilog$2 = {exports: {}};

function M() {
  this._events = {};
}

M.prototype = {
  on: function on(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function removeListener(ev, cb) {
    var e = this._events[ev] || [],
        i;

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      if (e[i] === cb || e[i].cb === cb) {
        e.splice(i, 1);
      }
    }
  },
  removeAllListeners: function removeAllListeners(ev) {
    if (!ev) {
      this._events = {};
    } else {
      this._events[ev] && (this._events[ev] = []);
    }
  },
  listeners: function listeners(ev) {
    return this._events ? this._events[ev] || [] : [];
  },
  emit: function emit(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1),
        i,
        e = this._events[ev] || [];

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      e[i].apply(this, args);
    }

    return this;
  },
  when: function when(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function once(ev, cb, when) {
    if (!cb) return this;

    function c() {
      if (!when) this.removeListener(ev, c);
      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }

    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};

M.mixin = function (dest) {
  var o = M.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var microee$1 = M;

var microee = microee$1; // Implements a subset of Node's stream.Transform - in a cross-platform manner.

function Transform$7() {}

microee.mixin(Transform$7); // The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.

Transform$7.prototype.write = function (name, level, args) {
  this.emit('item', name, level, args);
};

Transform$7.prototype.end = function () {
  this.emit('end');
  this.removeAllListeners();
};

Transform$7.prototype.pipe = function (dest) {
  var s = this; // prevent double piping

  s.emit('unpipe', dest); // tell the dest that it's being piped to

  dest.emit('pipe', s);

  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }

  function onEnd() {
    !dest._isStdio && dest.end();
  }

  s.on('item', onItem);
  s.on('end', onEnd);
  s.when('unpipe', function (from) {
    var match = from === dest || typeof from == 'undefined';

    if (match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }

    return match;
  });
  return dest;
};

Transform$7.prototype.unpipe = function (from) {
  this.emit('unpipe', from);
  return this;
};

Transform$7.prototype.format = function (dest) {
  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
};

Transform$7.mixin = function (dest) {
  var o = Transform$7.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var transform = Transform$7;

var Transform$6 = transform;
var levelMap = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};

function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}

Transform$6.mixin(Filter); // allow all matching, with level >= given level

Filter.prototype.allow = function (name, level) {
  this._white.push({
    n: name,
    l: levelMap[level]
  });

  return this;
}; // deny all matching, with level <= given level


Filter.prototype.deny = function (name, level) {
  this._black.push({
    n: name,
    l: levelMap[level]
  });

  return this;
};

Filter.prototype.clear = function () {
  this._white = [];
  this._black = [];
  return this;
};

function test(rule, name) {
  // use .test for RegExps
  return rule.n.test ? rule.n.test(name) : rule.n == name;
}

Filter.prototype.test = function (name, level) {
  var i,
      len = Math.max(this._white.length, this._black.length);

  for (i = 0; i < len; i++) {
    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }

    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }

  return this.defaultResult;
};

Filter.prototype.write = function (name, level, args) {
  if (!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};

var filter = Filter;

(function (module, exports) {
  var Transform = transform,
      Filter = filter;
  var log = new Transform(),
      slice = Array.prototype.slice;

  exports = module.exports = function create(name) {
    var o = function o() {
      log.write(name, undefined, slice.call(arguments));
      return o;
    };

    o.debug = function () {
      log.write(name, 'debug', slice.call(arguments));
      return o;
    };

    o.info = function () {
      log.write(name, 'info', slice.call(arguments));
      return o;
    };

    o.warn = function () {
      log.write(name, 'warn', slice.call(arguments));
      return o;
    };

    o.error = function () {
      log.write(name, 'error', slice.call(arguments));
      return o;
    };

    o.log = o.debug; // for interface compliance with Node and browser consoles

    o.suggest = exports.suggest;
    o.format = log.format;
    return o;
  }; // filled in separately


  exports.defaultBackend = exports.defaultFormatter = null;

  exports.pipe = function (dest) {
    return log.pipe(dest);
  };

  exports.end = exports.unpipe = exports.disable = function (from) {
    return log.unpipe(from);
  };

  exports.Transform = Transform;
  exports.Filter = Filter; // this is the default filter that's applied when .enable() is called normally
  // you can bypass it completely and set up your own pipes

  exports.suggest = new Filter();

  exports.enable = function () {
    if (exports.defaultFormatter) {
      return log.pipe(exports.suggest) // filter
      .pipe(exports.defaultFormatter) // formatter
      .pipe(exports.defaultBackend); // backend
    }

    return log.pipe(exports.suggest) // filter
    .pipe(exports.defaultBackend); // formatter
  };
})(minilog$2, minilog$2.exports);

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue: '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};

function color$2(fg, isInverse) {
  if (isInverse) {
    return 'color: #fff; background: ' + hex[fg] + ';';
  } else {
    return 'color: ' + hex[fg] + ';';
  }
}

var util = color$2;

var Transform$5 = transform,
    color$1 = util;
var colors$1 = {
  debug: ['cyan'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$4 = new Transform$5();

logger$4.write = function (name, level, args) {
  var fn = console.log;

  if (console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$4.pipe = function () {};

var color_1 = logger$4;

var Transform$4 = transform,
    color = util,
    colors = {
  debug: ['gray'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$3 = new Transform$4();

logger$3.write = function (name, level, args) {
  var fn = console.log;

  if (level != 'debug' && console[level]) {
    fn = console[level];
  }

  var i = 0;

  if (level != 'info') {
    for (; i < args.length; i++) {
      if (typeof args[i] != 'string') break;
    }

    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
  } else {
    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$3.pipe = function () {};

var minilog$1 = logger$3;

var Transform$3 = transform;
var newlines = /\n+$/,
    logger$2 = new Transform$3();

logger$2.write = function (name, level, args) {
  var i = args.length - 1;

  if (typeof console === 'undefined' || !console.log) {
    return;
  }

  if (console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if (JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if (args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }

    try {
      for (i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch (e) {}

    console.log(args.join(' '));
  }
};

logger$2.formatters = ['color', 'minilog'];
logger$2.color = color_1;
logger$2.minilog = minilog$1;
var console_1 = logger$2;

var Transform$2 = transform,
    cache$1 = [];
var logger$1 = new Transform$2();

logger$1.write = function (name, level, args) {
  cache$1.push([name, level, args]);
}; // utility functions


logger$1.get = function () {
  return cache$1;
};

logger$1.empty = function () {
  cache$1 = [];
};

var array = logger$1;

var Transform$1 = transform,
    cache = false;
var logger = new Transform$1();

logger.write = function (name, level, args) {
  if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;

  try {
    if (!cache) {
      cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
    }

    cache.push([new Date().toString(), name, level, args]);
    window.localStorage.minilog = JSON.stringify(cache);
  } catch (e) {}
};

var localstorage = logger;

var Transform = transform;
var cid = new Date().valueOf().toString(36);

function AjaxLogger(options) {
  this.url = options.url || '';
  this.cache = [];
  this.timer = null;
  this.interval = options.interval || 30 * 1000;
  this.enabled = true;
  this.jQuery = window.jQuery;
  this.extras = {};
}

Transform.mixin(AjaxLogger);

AjaxLogger.prototype.write = function (name, level, args) {
  if (!this.timer) {
    this.init();
  }

  this.cache.push([name, level].concat(args));
};

AjaxLogger.prototype.init = function () {
  if (!this.enabled || !this.jQuery) return;
  var self = this;
  this.timer = setTimeout(function () {
    var i,
        logs = [],
        ajaxData,
        url = self.url;
    if (self.cache.length == 0) return self.init(); // Test each log line and only log the ones that are valid (e.g. don't have circular references).
    // Slight performance hit but benefit is we log all valid lines.

    for (i = 0; i < self.cache.length; i++) {
      try {
        JSON.stringify(self.cache[i]);
        logs.push(self.cache[i]);
      } catch (e) {}
    }

    if (self.jQuery.isEmptyObject(self.extras)) {
      ajaxData = JSON.stringify({
        logs: logs
      });
      url = self.url + '?client_id=' + cid;
    } else {
      ajaxData = JSON.stringify(self.jQuery.extend({
        logs: logs
      }, self.extras));
    }

    self.jQuery.ajax(url, {
      type: 'POST',
      cache: false,
      processData: false,
      data: ajaxData,
      contentType: 'application/json',
      timeout: 10000
    }).success(function (data, status, jqxhr) {
      if (data.interval) {
        self.interval = Math.max(1000, data.interval);
      }
    }).error(function () {
      self.interval = 30000;
    }).always(function () {
      self.init();
    });
    self.cache = [];
  }, this.interval);
};

AjaxLogger.prototype.end = function () {}; // wait until jQuery is defined. Useful if you don't control the load order.


AjaxLogger.jQueryWait = function (onDone) {
  if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
    return onDone(window.jQuery || window.$);
  } else if (typeof window !== 'undefined') {
    setTimeout(function () {
      AjaxLogger.jQueryWait(onDone);
    }, 200);
  }
};

var jquery_simple = AjaxLogger;

(function (module, exports) {
  var Minilog = minilog$2.exports;
  var oldEnable = Minilog.enable,
      oldDisable = Minilog.disable,
      isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
      console = console_1; // Use a more capable logging backend if on Chrome

  Minilog.defaultBackend = isChrome ? console.minilog : console; // apply enable inputs from localStorage and from the URL

  if (typeof window != 'undefined') {
    try {
      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
    } catch (e) {}

    if (window.location && window.location.search) {
      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
      match && Minilog.enable(decodeURIComponent(match[1]));
    }
  } // Make enable also add to localStorage


  Minilog.enable = function () {
    oldEnable.call(Minilog, true);

    try {
      window.localStorage['minilogSettings'] = JSON.stringify(true);
    } catch (e) {}

    return this;
  };

  Minilog.disable = function () {
    oldDisable.call(Minilog);

    try {
      delete window.localStorage.minilogSettings;
    } catch (e) {}

    return this;
  };

  exports = module.exports = Minilog;
  exports.backends = {
    array: array,
    browser: Minilog.defaultBackend,
    localStorage: localstorage,
    jQuery: jquery_simple
  };
})(web, web.exports);

var minilog = web.exports;
minilog.enable();
var log$1 = minilog('vm');

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof$1(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof$1(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof$1(obj);
    };
  }

  return _typeof2(obj);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof_1 = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof_1 = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

var _typeof_1 = _typeof;
var _typeof$1 = _typeof_1;

var formatMessage$1 = {exports: {}};

var formatMessageParse = {exports: {}};

(function (module, exports) {
  /*::
  export type AST = Element[]
  export type Element = string | Placeholder
  export type Placeholder = Plural | Styled | Typed | Simple
  export type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]
  export type Styled = [ string, string, string | SubMessages ]
  export type Typed = [ string, string ]
  export type Simple = [ string ]
  export type SubMessages = { [string]: AST }
  export type Token = [ TokenType, string ]
  export type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'
  type Context = {|
    pattern: string,
    index: number,
    tagsType: ?string,
    tokens: ?Token[]
  |}
  */

  var ARG_OPN = '{';
  var ARG_CLS = '}';
  var ARG_SEP = ',';
  var NUM_ARG = '#';
  var TAG_OPN = '<';
  var TAG_CLS = '>';
  var TAG_END = '</';
  var TAG_SELF_CLS = '/>';
  var ESC = '\'';
  var OFFSET = 'offset:';
  var simpleTypes = ['number', 'date', 'time', 'ordinal', 'duration', 'spellout'];
  var submTypes = ['plural', 'select', 'selectordinal'];
  /**
   * parse
   *
   * Turns this:
   *  `You have { numBananas, plural,
   *       =0 {no bananas}
   *      one {a banana}
   *    other {# bananas}
   *  } for sale`
   *
   * into this:
   *  [ "You have ", [ "numBananas", "plural", 0, {
   *       "=0": [ "no bananas" ],
   *      "one": [ "a banana" ],
   *    "other": [ [ '#' ], " bananas" ]
   *  } ], " for sale." ]
   *
   * tokens:
   *  [
   *    [ "text", "You have " ],
   *    [ "syntax", "{" ],
   *    [ "space", " " ],
   *    [ "id", "numBananas" ],
   *    [ "syntax", ", " ],
   *    [ "space", " " ],
   *    [ "type", "plural" ],
   *    [ "syntax", "," ],
   *    [ "space", "\n     " ],
   *    [ "selector", "=0" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "text", "no bananas" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n    " ],
   *    [ "selector", "one" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "text", "a banana" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n  " ],
   *    [ "selector", "other" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "syntax", "#" ],
   *    [ "text", " bananas" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n" ],
   *    [ "syntax", "}" ],
   *    [ "text", " for sale." ]
   *  ]
   **/

  exports = module.exports = function parse(pattern
  /*: string */
  , options
  /*:: ?: { tagsType?: string, tokens?: Token[] } */
  )
  /*: AST */
  {
    return parseAST({
      pattern: String(pattern),
      index: 0,
      tagsType: options && options.tagsType || null,
      tokens: options && options.tokens || null
    }, '');
  };

  function parseAST(current
  /*: Context */
  , parentType
  /*: string */
  )
  /*: AST */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var elements
    /*: AST */
    = [];
    var start = current.index;
    var text = parseText(current, parentType);
    if (text) elements.push(text);
    if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);

    while (current.index < length) {
      if (pattern[current.index] === ARG_CLS) {
        if (!parentType) throw expected(current);
        break;
      }

      if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break;
      elements.push(parsePlaceholder(current));
      start = current.index;
      text = parseText(current, parentType);
      if (text) elements.push(text);
      if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);
    }

    return elements;
  }

  function parseText(current
  /*: Context */
  , parentType
  /*: string */
  )
  /*: string */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var isHashSpecial = parentType === 'plural' || parentType === 'selectordinal';
    var isAngleSpecial = !!current.tagsType;
    var isArgStyle = parentType === '{style}';
    var text = '';

    while (current.index < length) {
      var char = pattern[current.index];

      if (char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle && isWhitespace(char.charCodeAt(0))) {
        break;
      } else if (char === ESC) {
        char = pattern[++current.index];

        if (char === ESC) {
          // double is always 1 '
          text += char;
          ++current.index;
        } else if ( // only when necessary
        char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle) {
          text += char;

          while (++current.index < length) {
            char = pattern[current.index];

            if (char === ESC && pattern[current.index + 1] === ESC) {
              // double is always 1 '
              text += ESC;
              ++current.index;
            } else if (char === ESC) {
              // end of quoted
              ++current.index;
              break;
            } else {
              text += char;
            }
          }
        } else {
          // lone ' is just a '
          text += ESC; // already incremented
        }
      } else {
        text += char;
        ++current.index;
      }
    }

    return text;
  }

  function isWhitespace(code
  /*: number */
  )
  /*: boolean */
  {
    return code >= 0x09 && code <= 0x0D || code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E || code >= 0x2000 && code <= 0x200D || code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F || code === 0x2060 || code === 0x3000 || code === 0xFEFF;
  }

  function skipWhitespace(current
  /*: Context */
  )
  /*: void */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var start = current.index;

    while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {
      ++current.index;
    }

    if (start < current.index && current.tokens) {
      current.tokens.push(['space', current.pattern.slice(start, current.index)]);
    }
  }

  function parsePlaceholder(current
  /*: Context */
  )
  /*: Placeholder */
  {
    var pattern = current.pattern;

    if (pattern[current.index] === NUM_ARG) {
      if (current.tokens) current.tokens.push(['syntax', NUM_ARG]);
      ++current.index; // move passed #

      return [NUM_ARG];
    }

    var tag = parseTag(current);
    if (tag) return tag;
    /* istanbul ignore if should be unreachable if parseAST and parseText are right */

    if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN);
    if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);
    ++current.index; // move passed {

    skipWhitespace(current);
    var id = parseId(current);
    if (!id) throw expected(current, 'placeholder id');
    if (current.tokens) current.tokens.push(['id', id]);
    skipWhitespace(current);
    var char = pattern[current.index];

    if (char === ARG_CLS) {
      // end placeholder
      if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
      ++current.index; // move passed }

      return [id];
    }

    if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);
    if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);
    ++current.index; // move passed ,

    skipWhitespace(current);
    var type = parseId(current);
    if (!type) throw expected(current, 'placeholder type');
    if (current.tokens) current.tokens.push(['type', type]);
    skipWhitespace(current);
    char = pattern[current.index];

    if (char === ARG_CLS) {
      // end placeholder
      if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);

      if (type === 'plural' || type === 'selectordinal' || type === 'select') {
        throw expected(current, type + ' sub-messages');
      }

      ++current.index; // move passed }

      return [id, type];
    }

    if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);
    if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);
    ++current.index; // move passed ,

    skipWhitespace(current);
    var arg;

    if (type === 'plural' || type === 'selectordinal') {
      var offset = parsePluralOffset(current);
      skipWhitespace(current);
      arg = [id, type, offset, parseSubMessages(current, type)];
    } else if (type === 'select') {
      arg = [id, type, parseSubMessages(current, type)];
    } else if (simpleTypes.indexOf(type) >= 0) {
      arg = [id, type, parseSimpleFormat(current)];
    } else {
      // custom placeholder type
      var index = current.index;
      var format
      /*: string | SubMessages */
      = parseSimpleFormat(current);
      skipWhitespace(current);

      if (pattern[current.index] === ARG_OPN) {
        current.index = index; // rewind, since should have been submessages

        format = parseSubMessages(current, type);
      }

      arg = [id, type, format];
    }

    skipWhitespace(current);
    if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS);
    if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
    ++current.index; // move passed }

    return arg;
  }

  function parseTag(current
  /*: Context */
  )
  /*: ?Placeholder */
  {
    var tagsType = current.tagsType;
    if (!tagsType || current.pattern[current.index] !== TAG_OPN) return;

    if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {
      throw expected(current, null, 'closing tag without matching opening tag');
    }

    if (current.tokens) current.tokens.push(['syntax', TAG_OPN]);
    ++current.index; // move passed <

    var id = parseId(current, true);
    if (!id) throw expected(current, 'placeholder id');
    if (current.tokens) current.tokens.push(['id', id]);
    skipWhitespace(current);

    if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {
      if (current.tokens) current.tokens.push(['syntax', TAG_SELF_CLS]);
      current.index += TAG_SELF_CLS.length;
      return [id, tagsType];
    }

    if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);
    if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);
    ++current.index; // move passed >

    var children = parseAST(current, tagsType);
    var end = current.index;
    if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS);
    if (current.tokens) current.tokens.push(['syntax', TAG_END]);
    current.index += TAG_END.length;
    var closeId = parseId(current, true);
    if (closeId && current.tokens) current.tokens.push(['id', closeId]);

    if (id !== closeId) {
      current.index = end; // rewind for better error message

      throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS);
    }

    skipWhitespace(current);
    if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);
    if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);
    ++current.index; // move passed >

    return [id, tagsType, {
      children: children
    }];
  }

  function parseId(current
  /*: Context */
  , isTag
  /*:: ?: boolean */
  )
  /*: string */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var id = '';

    while (current.index < length) {
      var char = pattern[current.index];
      if (char === ARG_OPN || char === ARG_CLS || char === ARG_SEP || char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) || isTag && (char === TAG_OPN || char === TAG_CLS || char === '/')) break;
      id += char;
      ++current.index;
    }

    return id;
  }

  function parseSimpleFormat(current
  /*: Context */
  )
  /*: string */
  {
    var start = current.index;
    var style = parseText(current, '{style}');
    if (!style) throw expected(current, 'placeholder style name');
    if (current.tokens) current.tokens.push(['style', current.pattern.slice(start, current.index)]);
    return style;
  }

  function parsePluralOffset(current
  /*: Context */
  )
  /*: number */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var offset = 0;

    if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {
      if (current.tokens) current.tokens.push(['offset', 'offset'], ['syntax', ':']);
      current.index += OFFSET.length; // move passed offset:

      skipWhitespace(current);
      var start = current.index;

      while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {
        ++current.index;
      }

      if (start === current.index) throw expected(current, 'offset number');
      if (current.tokens) current.tokens.push(['number', pattern.slice(start, current.index)]);
      offset = +pattern.slice(start, current.index);
    }

    return offset;
  }

  function isDigit(code
  /*: number */
  )
  /*: boolean */
  {
    return code >= 0x30 && code <= 0x39;
  }

  function parseSubMessages(current
  /*: Context */
  , parentType
  /*: string */
  )
  /*: SubMessages */
  {
    var pattern = current.pattern;
    var length = pattern.length;
    var options
    /*: SubMessages */
    = {};

    while (current.index < length && pattern[current.index] !== ARG_CLS) {
      var selector = parseId(current);
      if (!selector) throw expected(current, 'sub-message selector');
      if (current.tokens) current.tokens.push(['selector', selector]);
      skipWhitespace(current);
      options[selector] = parseSubMessage(current, parentType);
      skipWhitespace(current);
    }

    if (!options.other && submTypes.indexOf(parentType) >= 0) {
      throw expected(current, null, null, '"other" sub-message must be specified in ' + parentType);
    }

    return options;
  }

  function parseSubMessage(current
  /*: Context */
  , parentType
  /*: string */
  )
  /*: AST */
  {
    if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message');
    if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);
    ++current.index; // move passed {

    var message = parseAST(current, parentType);
    if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message');
    if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);
    ++current.index; // move passed }

    return message;
  }

  function expected(current
  /*: Context */
  , expected
  /*:: ?: ?string */
  , found
  /*:: ?: ?string */
  , message
  /*:: ?: string */
  ) {
    var pattern = current.pattern;
    var lines = pattern.slice(0, current.index).split(/\r?\n/);
    var offset = current.index;
    var line = lines.length;
    var column = lines.slice(-1)[0].length;
    found = found || (current.index >= pattern.length ? 'end of message pattern' : parseId(current) || pattern[current.index]);
    if (!message) message = errorMessage(expected, found);
    message += ' in ' + pattern.replace(/\r?\n/g, '\n');
    return new SyntaxError(message, expected, found, offset, line, column);
  }

  function errorMessage(expected
  /*: ?string */
  , found
  /* string */
  ) {
    if (!expected) return 'Unexpected ' + found + ' found';
    return 'Expected ' + expected + ' but found ' + found;
  }
  /**
   * SyntaxError
   *  Holds information about bad syntax found in a message pattern
   **/


  function SyntaxError(message
  /*: string */
  , expected
  /*: ?string */
  , found
  /*: ?string */
  , offset
  /*: number */
  , line
  /*: number */
  , column
  /*: number */
  ) {
    Error.call(this, message);
    this.name = 'SyntaxError';
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.offset = offset;
    this.line = line;
    this.column = column;
  }

  SyntaxError.prototype = Object.create(Error.prototype);
  exports.SyntaxError = SyntaxError;
})(formatMessageParse, formatMessageParse.exports);

var formatMessageInterpret = {exports: {}};

var LONG = 'long';
var SHORT = 'short';
var NARROW = 'narrow';
var NUMERIC = 'numeric';
var TWODIGIT = '2-digit';
/**
 * formatting information
 **/

var formatMessageFormats = {
  number: {
    decimal: {
      style: 'decimal'
    },
    integer: {
      style: 'decimal',
      maximumFractionDigits: 0
    },
    currency: {
      style: 'currency',
      currency: 'USD'
    },
    percent: {
      style: 'percent'
    },
    default: {
      style: 'decimal'
    }
  },
  date: {
    short: {
      month: NUMERIC,
      day: NUMERIC,
      year: TWODIGIT
    },
    medium: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    },
    long: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC
    },
    full: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC,
      weekday: LONG
    },
    default: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    }
  },
  time: {
    short: {
      hour: NUMERIC,
      minute: NUMERIC
    },
    medium: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    },
    long: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    full: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    default: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    }
  },
  duration: {
    default: {
      hours: {
        minimumIntegerDigits: 1,
        maximumFractionDigits: 0
      },
      minutes: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 0
      },
      seconds: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 3
      }
    }
  },
  parseNumberPattern: function parseNumberPattern(pattern
  /*: ?string */
  ) {
    if (!pattern) return;
    var options = {};
    var currency = pattern.match(/\b[A-Z]{3}\b/i);
    var syms = pattern.replace(/[^¤]/g, '').length;
    if (!syms && currency) syms = 1;

    if (syms) {
      options.style = 'currency';
      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name';
      options.currency = currency ? currency[0].toUpperCase() : 'USD';
    } else if (pattern.indexOf('%') >= 0) {
      options.style = 'percent';
    }

    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined;
    options.useGrouping = pattern.indexOf(',') >= 0;

    if (/E\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {
      var size = pattern.replace(/E\+?[@#0]+|[^@#0]/gi, '');
      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21);
      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21);
    } else {
      var parts = pattern.replace(/[^#0.]/g, '').split('.');
      var integer = parts[0];
      var n = integer.length - 1;

      while (integer[n] === '0') {
        --n;
      }

      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21);
      var fraction = parts[1] || '';
      n = 0;

      while (fraction[n] === '0') {
        ++n;
      }

      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20);

      while (fraction[n] === '#') {
        ++n;
      }

      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20);
    }

    return options;
  },
  parseDatePattern: function parseDatePattern(pattern
  /*: ?string */
  ) {
    if (!pattern) return;
    var options = {};

    for (var i = 0; i < pattern.length;) {
      var current = pattern[i];
      var n = 1;

      while (pattern[++i] === current) {
        ++n;
      }

      switch (current) {
        case 'G':
          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
          break;

        case 'y':
        case 'Y':
          options.year = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 'M':
        case 'L':
          n = Math.min(Math.max(n - 1, 0), 4);
          options.month = [NUMERIC, TWODIGIT, SHORT, LONG, NARROW][n];
          break;

        case 'E':
        case 'e':
        case 'c':
          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
          break;

        case 'd':
        case 'D':
          options.day = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 'h':
        case 'K':
          options.hour12 = true;
          options.hour = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 'H':
        case 'k':
          options.hour12 = false;
          options.hour = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 'm':
          options.minute = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 's':
        case 'S':
          options.second = n === 2 ? TWODIGIT : NUMERIC;
          break;

        case 'z':
        case 'Z':
        case 'v':
        case 'V':
          options.timeZoneName = n === 1 ? SHORT : LONG;
          break;
      }
    }

    return Object.keys(options).length ? options : undefined;
  }
};

// "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
// assumes normalized language tags, and matches in a case sensitive manner

var lookupClosestLocale = function lookupClosestLocale(locale
/*: string | string[] | void */
, available
/*: { [string]: any } */
)
/*: ?string */
{
  if (typeof locale === 'string' && available[locale]) return locale;
  var locales = [].concat(locale || []);

  for (var l = 0, ll = locales.length; l < ll; ++l) {
    var current = locales[l].split('-');

    while (current.length) {
      var candidate = current.join('-');
      if (available[candidate]) return candidate;
      current.pop();
    }
  }
};

/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */


var zero = 'zero',
    one = 'one',
    two = 'two',
    few = 'few',
    many = 'many',
    other = 'other';
var f = [function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return 0 <= n && n <= 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var n = +s;
  return i === 0 || n === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 0 ? zero : n === 1 ? one : n === 2 ? two : 3 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 99 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return i === 1 && v === 0 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 1 && n % 100 !== 11 ? one : 2 <= n % 10 && n % 10 <= 4 && (n % 100 < 12 || 14 < n % 100) ? few : n % 10 === 0 || 5 <= n % 10 && n % 10 <= 9 || 11 <= n % 100 && n % 100 <= 14 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 1 && n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91 ? one : n % 10 === 2 && n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92 ? two : (3 <= n % 10 && n % 10 <= 4 || n % 10 === 9) && (n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100) ? few : n !== 0 && n % 1000000 === 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var f = +(s + '.').split('.')[1];
  return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) || 2 <= f % 10 && f % 10 <= 4 && (f % 100 < 12 || 14 < f % 100) ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return i === 1 && v === 0 ? one : 2 <= i && i <= 4 && v === 0 ? few : v !== 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 0 ? zero : n === 1 ? one : n === 2 ? two : n === 3 ? few : n === 6 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
  var n = +s;
  return n === 1 || t !== 0 && (i === 0 || i === 1) ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var f = +(s + '.').split('.')[1];
  return v === 0 && i % 100 === 1 || f % 100 === 1 ? one : v === 0 && i % 100 === 2 || f % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || 3 <= f % 100 && f % 100 <= 4 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  return i === 0 || i === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var f = +(s + '.').split('.')[1];
  return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9 || v !== 0 && f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n === 2 ? two : 3 <= n && n <= 6 ? few : 7 <= n && n <= 10 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : 3 <= n && n <= 10 || 13 <= n && n <= 19 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return v === 0 && i % 10 === 1 ? one : v === 0 && i % 10 === 2 ? two : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few : v !== 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var n = +s;
  return i === 1 && v === 0 ? one : i === 2 && v === 0 ? two : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
  return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n === 2 ? two : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 0 ? zero : n === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var n = +s;
  return n === 0 ? zero : (i === 0 || i === 1) && n !== 0 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var f = +(s + '.').split('.')[1];
  var n = +s;
  return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one : 2 <= n % 10 && n % 10 <= 9 && (n % 100 < 11 || 19 < n % 100) ? few : f !== 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var v = (s + '.').split('.')[1].length;
  var f = +(s + '.').split('.')[1];
  var n = +s;
  return n % 10 === 0 || 11 <= n % 100 && n % 100 <= 19 || v === 2 && 11 <= f % 100 && f % 100 <= 19 ? zero : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var f = +(s + '.').split('.')[1];
  return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  var n = +s;
  return i === 1 && v === 0 ? one : v !== 0 || n === 0 || n !== 1 && 1 <= n % 100 && n % 100 <= 19 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n === 0 || 2 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 19 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return i === 1 && v === 0 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i !== 1 && 0 <= i % 10 && i % 10 <= 1 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 12 <= i % 100 && i % 100 <= 14 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  return 0 <= i && i <= 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i % 10 === 0 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 11 <= i % 100 && i % 100 <= 14 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var n = +s;
  return i === 0 || n === 1 ? one : 2 <= n && n <= 10 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var f = +(s + '.').split('.')[1];
  var n = +s;
  return n === 0 || n === 1 || i === 0 && f === 1 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  var v = (s + '.').split('.')[1].length;
  return v === 0 && i % 100 === 1 ? one : v === 0 && i % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || v !== 0 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return 0 <= n && n <= 1 || 11 <= n && n <= 99 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  return i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8 || i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80 ? one : i % 10 === 3 || i % 10 === 4 || i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900 ? few : i === 0 || i % 10 === 6 || i % 100 === 40 || i % 100 === 60 || i % 100 === 90 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return (n % 10 === 2 || n % 10 === 3) && n % 100 !== 12 && n % 100 !== 13 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 3 ? one : n === 2 ? two : n === 4 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 0 || n === 7 || n === 8 || n === 9 ? zero : n === 1 ? one : n === 2 ? two : n === 3 || n === 4 ? few : n === 5 || n === 6 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 1 && n % 100 !== 11 ? one : n % 10 === 2 && n % 100 !== 12 ? two : n % 10 === 3 && n % 100 !== 13 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : n === 3 || n === 13 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 5 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 11 || n === 8 || n === 80 || n === 800 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  return i === 1 ? one : i === 0 || 2 <= i % 100 && i % 100 <= 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var i = Math.floor(Math.abs(+s));
  return i % 10 === 1 && i % 100 !== 11 ? one : i % 10 === 2 && i % 100 !== 12 ? two : (i % 10 === 7 || i % 10 === 8) && i % 100 !== 17 && i % 100 !== 18 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return 1 <= n && n <= 4 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 || n === 5 || 7 <= n && n <= 9 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n === 1 ? one : n % 10 === 4 && n % 100 !== 14 ? many : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return (n % 10 === 1 || n % 10 === 2) && n % 100 !== 11 && n % 100 !== 12 ? one : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 6 || n % 10 === 9 || n === 10 ? few : other;
}, function (s
/*: string | number */
)
/*: Rule */
{
  var n = +s;
  return n % 10 === 3 && n % 100 !== 13 ? few : other;
}];
var plurals = {
  af: {
    cardinal: f[0]
  },
  ak: {
    cardinal: f[1]
  },
  am: {
    cardinal: f[2]
  },
  ar: {
    cardinal: f[3]
  },
  ars: {
    cardinal: f[3]
  },
  as: {
    cardinal: f[2],
    ordinal: f[34]
  },
  asa: {
    cardinal: f[0]
  },
  ast: {
    cardinal: f[4]
  },
  az: {
    cardinal: f[0],
    ordinal: f[35]
  },
  be: {
    cardinal: f[5],
    ordinal: f[36]
  },
  bem: {
    cardinal: f[0]
  },
  bez: {
    cardinal: f[0]
  },
  bg: {
    cardinal: f[0]
  },
  bh: {
    cardinal: f[1]
  },
  bn: {
    cardinal: f[2],
    ordinal: f[34]
  },
  br: {
    cardinal: f[6]
  },
  brx: {
    cardinal: f[0]
  },
  bs: {
    cardinal: f[7]
  },
  ca: {
    cardinal: f[4],
    ordinal: f[37]
  },
  ce: {
    cardinal: f[0]
  },
  cgg: {
    cardinal: f[0]
  },
  chr: {
    cardinal: f[0]
  },
  ckb: {
    cardinal: f[0]
  },
  cs: {
    cardinal: f[8]
  },
  cy: {
    cardinal: f[9],
    ordinal: f[38]
  },
  da: {
    cardinal: f[10]
  },
  de: {
    cardinal: f[4]
  },
  dsb: {
    cardinal: f[11]
  },
  dv: {
    cardinal: f[0]
  },
  ee: {
    cardinal: f[0]
  },
  el: {
    cardinal: f[0]
  },
  en: {
    cardinal: f[4],
    ordinal: f[39]
  },
  eo: {
    cardinal: f[0]
  },
  es: {
    cardinal: f[0]
  },
  et: {
    cardinal: f[4]
  },
  eu: {
    cardinal: f[0]
  },
  fa: {
    cardinal: f[2]
  },
  ff: {
    cardinal: f[12]
  },
  fi: {
    cardinal: f[4]
  },
  fil: {
    cardinal: f[13],
    ordinal: f[0]
  },
  fo: {
    cardinal: f[0]
  },
  fr: {
    cardinal: f[12],
    ordinal: f[0]
  },
  fur: {
    cardinal: f[0]
  },
  fy: {
    cardinal: f[4]
  },
  ga: {
    cardinal: f[14],
    ordinal: f[0]
  },
  gd: {
    cardinal: f[15],
    ordinal: f[40]
  },
  gl: {
    cardinal: f[4]
  },
  gsw: {
    cardinal: f[0]
  },
  gu: {
    cardinal: f[2],
    ordinal: f[41]
  },
  guw: {
    cardinal: f[1]
  },
  gv: {
    cardinal: f[16]
  },
  ha: {
    cardinal: f[0]
  },
  haw: {
    cardinal: f[0]
  },
  he: {
    cardinal: f[17]
  },
  hi: {
    cardinal: f[2],
    ordinal: f[41]
  },
  hr: {
    cardinal: f[7]
  },
  hsb: {
    cardinal: f[11]
  },
  hu: {
    cardinal: f[0],
    ordinal: f[42]
  },
  hy: {
    cardinal: f[12],
    ordinal: f[0]
  },
  ia: {
    cardinal: f[4]
  },
  io: {
    cardinal: f[4]
  },
  is: {
    cardinal: f[18]
  },
  it: {
    cardinal: f[4],
    ordinal: f[43]
  },
  iu: {
    cardinal: f[19]
  },
  iw: {
    cardinal: f[17]
  },
  jgo: {
    cardinal: f[0]
  },
  ji: {
    cardinal: f[4]
  },
  jmc: {
    cardinal: f[0]
  },
  ka: {
    cardinal: f[0],
    ordinal: f[44]
  },
  kab: {
    cardinal: f[12]
  },
  kaj: {
    cardinal: f[0]
  },
  kcg: {
    cardinal: f[0]
  },
  kk: {
    cardinal: f[0],
    ordinal: f[45]
  },
  kkj: {
    cardinal: f[0]
  },
  kl: {
    cardinal: f[0]
  },
  kn: {
    cardinal: f[2]
  },
  ks: {
    cardinal: f[0]
  },
  ksb: {
    cardinal: f[0]
  },
  ksh: {
    cardinal: f[20]
  },
  ku: {
    cardinal: f[0]
  },
  kw: {
    cardinal: f[19]
  },
  ky: {
    cardinal: f[0]
  },
  lag: {
    cardinal: f[21]
  },
  lb: {
    cardinal: f[0]
  },
  lg: {
    cardinal: f[0]
  },
  ln: {
    cardinal: f[1]
  },
  lt: {
    cardinal: f[22]
  },
  lv: {
    cardinal: f[23]
  },
  mas: {
    cardinal: f[0]
  },
  mg: {
    cardinal: f[1]
  },
  mgo: {
    cardinal: f[0]
  },
  mk: {
    cardinal: f[24],
    ordinal: f[46]
  },
  ml: {
    cardinal: f[0]
  },
  mn: {
    cardinal: f[0]
  },
  mo: {
    cardinal: f[25],
    ordinal: f[0]
  },
  mr: {
    cardinal: f[2],
    ordinal: f[47]
  },
  mt: {
    cardinal: f[26]
  },
  nah: {
    cardinal: f[0]
  },
  naq: {
    cardinal: f[19]
  },
  nb: {
    cardinal: f[0]
  },
  nd: {
    cardinal: f[0]
  },
  ne: {
    cardinal: f[0],
    ordinal: f[48]
  },
  nl: {
    cardinal: f[4]
  },
  nn: {
    cardinal: f[0]
  },
  nnh: {
    cardinal: f[0]
  },
  no: {
    cardinal: f[0]
  },
  nr: {
    cardinal: f[0]
  },
  nso: {
    cardinal: f[1]
  },
  ny: {
    cardinal: f[0]
  },
  nyn: {
    cardinal: f[0]
  },
  om: {
    cardinal: f[0]
  },
  or: {
    cardinal: f[0],
    ordinal: f[49]
  },
  os: {
    cardinal: f[0]
  },
  pa: {
    cardinal: f[1]
  },
  pap: {
    cardinal: f[0]
  },
  pl: {
    cardinal: f[27]
  },
  prg: {
    cardinal: f[23]
  },
  ps: {
    cardinal: f[0]
  },
  pt: {
    cardinal: f[28]
  },
  'pt-PT': {
    cardinal: f[4]
  },
  rm: {
    cardinal: f[0]
  },
  ro: {
    cardinal: f[25],
    ordinal: f[0]
  },
  rof: {
    cardinal: f[0]
  },
  ru: {
    cardinal: f[29]
  },
  rwk: {
    cardinal: f[0]
  },
  saq: {
    cardinal: f[0]
  },
  sc: {
    cardinal: f[4],
    ordinal: f[43]
  },
  scn: {
    cardinal: f[4],
    ordinal: f[43]
  },
  sd: {
    cardinal: f[0]
  },
  sdh: {
    cardinal: f[0]
  },
  se: {
    cardinal: f[19]
  },
  seh: {
    cardinal: f[0]
  },
  sh: {
    cardinal: f[7]
  },
  shi: {
    cardinal: f[30]
  },
  si: {
    cardinal: f[31]
  },
  sk: {
    cardinal: f[8]
  },
  sl: {
    cardinal: f[32]
  },
  sma: {
    cardinal: f[19]
  },
  smi: {
    cardinal: f[19]
  },
  smj: {
    cardinal: f[19]
  },
  smn: {
    cardinal: f[19]
  },
  sms: {
    cardinal: f[19]
  },
  sn: {
    cardinal: f[0]
  },
  so: {
    cardinal: f[0]
  },
  sq: {
    cardinal: f[0],
    ordinal: f[50]
  },
  sr: {
    cardinal: f[7]
  },
  ss: {
    cardinal: f[0]
  },
  ssy: {
    cardinal: f[0]
  },
  st: {
    cardinal: f[0]
  },
  sv: {
    cardinal: f[4],
    ordinal: f[51]
  },
  sw: {
    cardinal: f[4]
  },
  syr: {
    cardinal: f[0]
  },
  ta: {
    cardinal: f[0]
  },
  te: {
    cardinal: f[0]
  },
  teo: {
    cardinal: f[0]
  },
  ti: {
    cardinal: f[1]
  },
  tig: {
    cardinal: f[0]
  },
  tk: {
    cardinal: f[0],
    ordinal: f[52]
  },
  tl: {
    cardinal: f[13],
    ordinal: f[0]
  },
  tn: {
    cardinal: f[0]
  },
  tr: {
    cardinal: f[0]
  },
  ts: {
    cardinal: f[0]
  },
  tzm: {
    cardinal: f[33]
  },
  ug: {
    cardinal: f[0]
  },
  uk: {
    cardinal: f[29],
    ordinal: f[53]
  },
  ur: {
    cardinal: f[4]
  },
  uz: {
    cardinal: f[0]
  },
  ve: {
    cardinal: f[0]
  },
  vo: {
    cardinal: f[0]
  },
  vun: {
    cardinal: f[0]
  },
  wa: {
    cardinal: f[1]
  },
  wae: {
    cardinal: f[0]
  },
  xh: {
    cardinal: f[0]
  },
  xog: {
    cardinal: f[0]
  },
  yi: {
    cardinal: f[4]
  },
  zu: {
    cardinal: f[2]
  },
  lo: {
    ordinal: f[0]
  },
  ms: {
    ordinal: f[0]
  },
  vi: {
    ordinal: f[0]
  }
};

(function (module, exports) {

  var formats = formatMessageFormats;
  var lookupClosestLocale$1 = lookupClosestLocale;
  var plurals$1 = plurals;
  /*::
  import type {
    AST,
    SubMessages
  } from '../format-message-parse'
  type Locale = string
  type Locales = Locale | Locale[]
  type Placeholder = any[] // https://github.com/facebook/flow/issues/4050
  export type Type = (Placeholder, Locales) => (any, ?Object) => any
  export type Types = { [string]: Type }
  */

  exports = module.exports = function interpret(ast
  /*: AST */
  , locale
  /*:: ?: Locales */
  , types
  /*:: ?: Types */
  )
  /*: (args?: Object) => string */
  {
    return interpretAST(ast, null, locale || 'en', types || {}, true);
  };

  exports.toParts = function toParts(ast
  /*: AST */
  , locale
  /*:: ?: Locales */
  , types
  /*:: ?: Types */
  )
  /*: (args?: Object) => any[] */
  {
    return interpretAST(ast, null, locale || 'en', types || {}, false);
  };

  function interpretAST(elements
  /*: any[] */
  , parent
  /*: ?Placeholder */
  , locale
  /*: Locales */
  , types
  /*: Types */
  , join
  /*: boolean */
  )
  /*: Function */
  {
    var parts = elements.map(function (element) {
      return interpretElement(element, parent, locale, types, join);
    });

    if (!join) {
      return function format(args) {
        return parts.reduce(function (parts, part) {
          return parts.concat(part(args));
        }, []);
      };
    }

    if (parts.length === 1) return parts[0];
    return function format(args) {
      var message = '';

      for (var e = 0; e < parts.length; ++e) {
        message += parts[e](args);
      }

      return message;
    };
  }

  function interpretElement(element
  /*: Placeholder */
  , parent
  /*: ?Placeholder */
  , locale
  /*: Locales */
  , types
  /*: Types */
  , join
  /*: boolean */
  )
  /*: Function */
  {
    if (typeof element === 'string') {
      var value
      /*: string */
      = element;
      return function format() {
        return value;
      };
    }

    var id = element[0];
    var type = element[1];

    if (parent && element[0] === '#') {
      id = parent[0];
      var offset = parent[2];
      var formatter = (types.number || defaults.number)([id, 'number'], locale);
      return function format(args) {
        return formatter(getArg(id, args) - offset, args);
      };
    } // pre-process children


    var children;

    if (type === 'plural' || type === 'selectordinal') {
      children = {};
      Object.keys(element[3]).forEach(function (key) {
        children[key] = interpretAST(element[3][key], element, locale, types, join);
      });
      element = [element[0], element[1], element[2], children];
    } else if (element[2] && _typeof$1(element[2]) === 'object') {
      children = {};
      Object.keys(element[2]).forEach(function (key) {
        children[key] = interpretAST(element[2][key], element, locale, types, join);
      });
      element = [element[0], element[1], children];
    }

    var getFrmt = type && (types[type] || defaults[type]);

    if (getFrmt) {
      var frmt = getFrmt(element, locale);
      return function format(args) {
        return frmt(getArg(id, args), args);
      };
    }

    return join ? function format(args) {
      return String(getArg(id, args));
    } : function format(args) {
      return getArg(id, args);
    };
  }

  function getArg(id
  /*: string */
  , args
  /*: ?Object */
  )
  /*: any */
  {
    if (args && id in args) return args[id];
    var parts = id.split('.');
    var a = args;

    for (var i = 0, ii = parts.length; a && i < ii; ++i) {
      a = a[parts[i]];
    }

    return a;
  }

  function interpretNumber(element
  /*: Placeholder */
  , locales
  /*: Locales */
  ) {
    var style = element[2];
    var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;
    return new Intl.NumberFormat(locales, options).format;
  }

  function interpretDuration(element
  /*: Placeholder */
  , locales
  /*: Locales */
  ) {
    var style = element[2];
    var options = formats.duration[style] || formats.duration.default;
    var fs = new Intl.NumberFormat(locales, options.seconds).format;
    var fm = new Intl.NumberFormat(locales, options.minutes).format;
    var fh = new Intl.NumberFormat(locales, options.hours).format;
    var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':';
    return function (s, args) {
      s = +s;
      if (!isFinite(s)) return fs(s);
      var h = ~~(s / 60 / 60); // ~~ acts much like Math.trunc

      var m = ~~(s / 60 % 60);
      var dur = (h ? fh(Math.abs(h)) + sep : '') + fm(Math.abs(m)) + sep + fs(Math.abs(s % 60));
      return s < 0 ? fh(-1).replace(fh(1), dur) : dur;
    };
  }

  function interpretDateTime(element
  /*: Placeholder */
  , locales
  /*: Locales */
  ) {
    var type = element[1];
    var style = element[2];
    var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default;
    return new Intl.DateTimeFormat(locales, options).format;
  }

  function interpretPlural(element
  /*: Placeholder */
  , locales
  /*: Locales */
  ) {
    var type = element[1];
    var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal';
    var offset = element[2];
    var children = element[3];
    var pluralRules;

    if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {
      pluralRules = new Intl.PluralRules(locales, {
        type: pluralType
      });
    } else {
      var locale = lookupClosestLocale$1(locales, plurals$1);
      var select = locale && plurals$1[locale][pluralType] || returnOther;
      pluralRules = {
        select: select
      };
    }

    return function (value, args) {
      var clause = children['=' + +value] || children[pluralRules.select(value - offset)] || children.other;
      return clause(args);
    };
  }

  function
    /*:: n:number */
  returnOther() {
    return 'other';
  }

  function interpretSelect(element
  /*: Placeholder */
  , locales
  /*: Locales */
  ) {
    var children = element[2];
    return function (value, args) {
      var clause = children[value] || children.other;
      return clause(args);
    };
  }

  var defaults
  /*: Types */
  = {
    number: interpretNumber,
    ordinal: interpretNumber,
    // TODO: support rbnf
    spellout: interpretNumber,
    // TODO: support rbnf
    duration: interpretDuration,
    date: interpretDateTime,
    time: interpretDateTime,
    plural: interpretPlural,
    selectordinal: interpretPlural,
    select: interpretSelect
  };
  exports.types = defaults;
})(formatMessageInterpret, formatMessageInterpret.exports);

(function (module, exports) {

  var parse = formatMessageParse.exports;
  var interpret = formatMessageInterpret.exports;
  var plurals$1 = plurals;
  var lookupClosestLocale$1 = lookupClosestLocale;
  var origFormats = formatMessageFormats;
  /*::
  import type { Types } from 'format-message-interpret'
  type Locale = string
  type Locales = Locale | Locale[]
  type Message = string | {|
    id?: string,
    default: string,
    description?: string
  |}
  type Translations = { [string]: ?{ [string]: string | Translation } }
  type Translation = {
    message: string,
    format?: (args?: Object) => string,
    toParts?: (args?: Object) => any[],
  }
  type Replacement = ?string | (string, string, locales?: Locales) => ?string
  type GenerateId = (string) => string
  type MissingTranslation = 'ignore' | 'warning' | 'error'
  type FormatObject = { [string]: * }
  type Options = {
    locale?: Locales,
    translations?: ?Translations,
    generateId?: GenerateId,
    missingReplacement?: Replacement,
    missingTranslation?: MissingTranslation,
    formats?: {
      number?: FormatObject,
      date?: FormatObject,
      time?: FormatObject
    },
    types?: Types
  }
  type Setup = {|
    locale: Locales,
    translations: Translations,
    generateId: GenerateId,
    missingReplacement: Replacement,
    missingTranslation: MissingTranslation,
    formats: {
      number: FormatObject,
      date: FormatObject,
      time: FormatObject
    },
    types: Types
  |}
  type FormatMessage = {
    (msg: Message, args?: Object, locales?: Locales): string,
    rich (msg: Message, args?: Object, locales?: Locales): any[],
    setup (opt?: Options): Setup,
    number (value: number, style?: string, locales?: Locales): string,
    date (value: number | Date, style?: string, locales?: Locales): string,
    time (value: number | Date, style?: string, locales?: Locales): string,
    select (value: any, options: Object): any,
    custom (placeholder: any[], locales: Locales, value: any, args: Object): any,
    plural (value: number, offset: any, options: any, locale: any): any,
    selectordinal (value: number, offset: any, options: any, locale: any): any,
    namespace (): FormatMessage
  }
  */

  function assign
  /*:: <T: Object> */
  (target
  /*: T */
  , source
  /*: Object */
  ) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
    return target;
  }

  function namespace()
  /*: FormatMessage */
  {
    var formats = assign({}, origFormats);
    var currentLocales
    /*: Locales */
    = 'en';
    var translations
    /*: Translations */
    = {};

    var generateId
    /*: GenerateId */
    = function generateId(pattern) {
      return pattern;
    };

    var missingReplacement
    /*: Replacement */
    = null;
    var missingTranslation
    /*: MissingTranslation */
    = 'warning';
    var types
    /*: Types */
    = {};

    function formatMessage(msg
    /*: Message */
    , args
    /*:: ?: Object */
    , locales
    /*:: ?: Locales */
    ) {
      var pattern = typeof msg === 'string' ? msg : msg.default;
      var id = _typeof$1(msg) === 'object' && msg.id || generateId(pattern);
      var translated = translate(pattern, id, locales || currentLocales);
      var format = translated.format || (translated.format = interpret(parse(translated.message), locales || currentLocales, types));
      return format(args);
    }

    formatMessage.rich = function rich(msg
    /*: Message */
    , args
    /*:: ?: Object */
    , locales
    /*:: ?: Locales */
    ) {
      var pattern = typeof msg === 'string' ? msg : msg.default;
      var id = _typeof$1(msg) === 'object' && msg.id || generateId(pattern);
      var translated = translate(pattern, id, locales || currentLocales);
      var format = translated.toParts || (translated.toParts = interpret.toParts(parse(translated.message, {
        tagsType: tagsType
      }), locales || currentLocales, types));
      return format(args);
    };

    var tagsType = '<>';

    function richType(node
    /*: any[] */
    , locales
    /*: Locales */
    ) {
      var style = node[2];
      return function (fn, args) {
        var props = _typeof$1(style) === 'object' ? mapObject(style, args) : style;
        return typeof fn === 'function' ? fn(props) : fn;
      };
    }

    types[tagsType] = richType;

    function mapObject(object
    /* { [string]: (args?: Object) => any } */
    , args
    /*: ?Object */
    ) {
      return Object.keys(object).reduce(function (mapped, key) {
        mapped[key] = object[key](args);
        return mapped;
      }, {});
    }

    function translate(pattern
    /*: string */
    , id
    /*: string */
    , locales
    /*: Locales */
    )
    /*: Translation */
    {
      var locale = lookupClosestLocale$1(locales, translations) || 'en';
      var messages = translations[locale] || (translations[locale] = {});
      var translated = messages[id];

      if (typeof translated === 'string') {
        translated = messages[id] = {
          message: translated
        };
      }

      if (!translated) {
        var message = 'Translation for "' + id + '" in "' + locale + '" is missing';

        if (missingTranslation === 'warning') {
          /* istanbul ignore else */
          if (typeof console !== 'undefined') console.warn(message);
        } else if (missingTranslation !== 'ignore') {
          // 'error'
          throw new Error(message);
        }

        var replacement = typeof missingReplacement === 'function' ? missingReplacement(pattern, id, locale) || pattern : missingReplacement || pattern;
        translated = messages[id] = {
          message: replacement
        };
      }

      return translated;
    }

    formatMessage.setup = function setup(opt
    /*:: ?: Options */
    ) {
      opt = opt || {};
      if (opt.locale) currentLocales = opt.locale;
      if ('translations' in opt) translations = opt.translations || {};
      if (opt.generateId) generateId = opt.generateId;
      if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement;
      if (opt.missingTranslation) missingTranslation = opt.missingTranslation;

      if (opt.formats) {
        if (opt.formats.number) assign(formats.number, opt.formats.number);
        if (opt.formats.date) assign(formats.date, opt.formats.date);
        if (opt.formats.time) assign(formats.time, opt.formats.time);
      }

      if (opt.types) {
        types = opt.types;
        types[tagsType] = richType;
      }

      return {
        locale: currentLocales,
        translations: translations,
        generateId: generateId,
        missingReplacement: missingReplacement,
        missingTranslation: missingTranslation,
        formats: formats,
        types: types
      };
    };

    formatMessage.number = function (value
    /*: number */
    , style
    /*:: ?: string */
    , locales
    /*:: ?: Locales */
    ) {
      var options = style && formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;
      return new Intl.NumberFormat(locales || currentLocales, options).format(value);
    };

    formatMessage.date = function (value
    /*:: ?: number | Date */
    , style
    /*:: ?: string */
    , locales
    /*:: ?: Locales */
    ) {
      var options = style && formats.date[style] || formats.parseDatePattern(style) || formats.date.default;
      return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);
    };

    formatMessage.time = function (value
    /*:: ?: number | Date */
    , style
    /*:: ?: string */
    , locales
    /*:: ?: Locales */
    ) {
      var options = style && formats.time[style] || formats.parseDatePattern(style) || formats.time.default;
      return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);
    };

    formatMessage.select = function (value
    /*: any */
    , options
    /*: Object */
    ) {
      return options[value] || options.other;
    };

    formatMessage.custom = function (placeholder
    /*: any[] */
    , locales
    /*: Locales */
    , value
    /*: any */
    , args
    /*: Object */
    ) {
      if (!(placeholder[1] in types)) return value;
      return types[placeholder[1]](placeholder, locales)(value, args);
    };

    formatMessage.plural = plural.bind(null, 'cardinal');
    formatMessage.selectordinal = plural.bind(null, 'ordinal');

    function plural(pluralType
    /*: 'cardinal' | 'ordinal' */
    , value
    /*: number */
    , offset
    /*: any */
    , options
    /*: any */
    , locale
    /*: any */
    ) {
      if (_typeof$1(offset) === 'object' && _typeof$1(options) !== 'object') {
        // offset is optional
        locale = options;
        options = offset;
        offset = 0;
      }

      var closest = lookupClosestLocale$1(locale || currentLocales, plurals$1);
      var plural = closest && plurals$1[closest][pluralType] || returnOther;
      return options['=' + +value] || options[plural(value - offset)] || options.other;
    }

    function
      /*:: n:number */
    returnOther() {
      return 'other';
    }

    formatMessage.namespace = namespace;
    return formatMessage;
  }

  module.exports = namespace();
})(formatMessage$1);

var Timer$1 = /*#__PURE__*/function () {
  function Timer() {
    var nowObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Timer.nowObj;

    classCallCheck(this, Timer);

    /**
     * Used to store the start time of a timer action.
     * Updated when calling `timer.start`.
     */
    this.startTime = 0;
    /**
     * Used to pass custom logic for determining the value for "now",
     * which is sometimes useful for compatibility with Scratch 2
     */

    this.nowObj = nowObj;
  }
  /**
   * Disable use of self.performance for now as it results in lower performance
   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
   * @type {boolean}
   */


  createClass(Timer, [{
    key: "time",
    value:
    /**
     * Return the currently known absolute time, in ms precision.
     * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
     */
    function time() {
      return this.nowObj.now();
    }
    /**
     * Returns a time accurate relative to other times produced by this function.
     * If possible, will use sub-millisecond precision.
     * If not, will use millisecond precision.
     * Not guaranteed to produce the same absolute values per-system.
     * @returns {number} ms-scale accurate time relative to other relative times.
     */

  }, {
    key: "relativeTime",
    value: function relativeTime() {
      return this.nowObj.now();
    }
    /**
     * Start a timer for measuring elapsed time,
     * at the most accurate precision possible.
     */

  }, {
    key: "start",
    value: function start() {
      this.startTime = this.nowObj.now();
    }
  }, {
    key: "timeElapsed",
    value: function timeElapsed() {
      return this.nowObj.now() - this.startTime;
    }
    /**
     * Call a handler function after a specified amount of time has elapsed.
     * @param {function} handler - function to call after the timeout
     * @param {number} timeout - number of milliseconds to delay before calling the handler
     * @returns {number} - the ID of the new timeout
     */

  }, {
    key: "setTimeout",
    value: function setTimeout(handler, timeout) {
      return commonjsGlobal.setTimeout(handler, timeout);
    }
    /**
     * Clear a timeout from the pending timeout pool.
     * @param {number} timeoutId - the ID returned by `setTimeout()`
     * @memberof Timer
     */

  }, {
    key: "clearTimeout",
    value: function clearTimeout(timeoutId) {
      commonjsGlobal.clearTimeout(timeoutId);
    }
  }], [{
    key: "USE_PERFORMANCE",
    get: function get() {
      return false;
    }
    /**
     * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
     * @deprecated This is only called via the nowObj.now() if no other means is possible...
     */

  }, {
    key: "legacyDateCode",
    get: function get() {
      return {
        now: function now() {
          return new Date().getTime();
        }
      };
    }
    /**
     * Use this object to route all time functions through single access points.
     */

  }, {
    key: "nowObj",
    get: function get() {
      if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {
        return self.performance;
      } else if (Date.now) {
        return Date;
      }

      return Timer.legacyDateCode;
    }
  }]);

  return Timer;
}();

var timer = Timer$1;

var ArgumentType = argumentType;
var BlockType = blockType;
var Cast = cast;
var log = log$1;
var formatMessage = formatMessage$1.exports;
var Timer = timer;
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

var blockIconURI = 'data:image/png;base64,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';
/**
 * Icon svg to be displayed in the category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
//const menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48ZyBpZD0iSUQwLjA4NjgyNDQzOTAwMDMzODMyIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjQ5MTU0NjY2MDY2MTY5NzQsIDAsIDAsIDAuNDkxNTQ2NjYwNjYxNjk3NCwgLTY0LjUsIC03Ny4yNSkiPjxwYXRoIGlkPSJJRDAuNTcyMTQ2MjMwMzc3MjU2OSIgZmlsbD0iI0ZGOTQwMCIgc3Ryb2tlPSJub25lIiBkPSJNIDE4OCAxNDEgTCAyNTAgMTQxIEwgMjUwIDIwMyBMIDE4OCAyMDMgTCAxODggMTQxIFogIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjI4NzkwMzMwODg2ODQwODIsIDAsIDAsIDEuMjg3OTAzMzA4ODY4NDA4MiwgLTExMC45LCAtMjQuNCkiLz48cGF0aCBpZD0iSUQwLjYzODMzNjEzNTA3NDQ5NjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0gMTk2IDIwNCBDIDE5NiAyMDQgMTkyLjcwNiAxOTAuMDU4IDE5MyAxODMgQyAxOTMuMDc0IDE4MS4yMzYgMTk1Ljg4NiAxNzguNDU4IDE5NyAxODAgQyAyMDEuNDU1IDE4Ni4xNjggMjAzLjQ0MyAyMDMuNzU0IDIwNiAyMDEgQyAyMDkuMjExIDE5Ny41NDIgMjEwIDE2NiAyMTAgMTY2ICIgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgLTU3LCAxNS44KSIvPjxwYXRoIGlkPSJJRDAuNzU4NzMwMzU2NTgxNTA5MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTSAyMTUgMTY5IEMgMjE1IDE2OSAyMTguMzY3IDE2OS41MzQgMjIwIDE3MCBDIDIyMC43MTYgMTcwLjIwNSAyMjEuMjc4IDE3MC44MTkgMjIyIDE3MSBDIDIyMi42NDYgMTcxLjE2MiAyMjMuMzY4IDE3MC43ODkgMjI0IDE3MSBDIDIyNC40NDcgMTcxLjE0OSAyMjUgMTcyIDIyNSAxNzIgIiB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAtNTcsIDE1LjgpIi8+PHBhdGggaWQ9IklEMC4yNDM2NzMwNzMxMjc4NjU4IiBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNIDIyNyAxNTQgQyAyMjcgMTU0IDIxOC41NTUgMTQ3Ljg5MCAyMTcgMTUxIEMgMjEyLjM0NSAxNjAuMzEwIDIxMS4yODkgMTcxLjczMyAyMTMgMTgyIEMgMjEzLjYxMiAxODUuNjcyIDIyMyAxODcgMjIzIDE4NyAiIHRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIDEsIC01NywgMTUuOCkiLz48cGF0aCBpZD0iSUQwLjc5MzkzOTQ4MTk1NTAyMTYiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0gMTc1IDIwMC41MDAgQyAxNzUgMjAwLjUwMCAxNjkuODA1IDIyMS45MTMgMTcxIDIyMi43NTAgQyAxNzIuMTk1IDIyMy41ODcgMTc4Ljc5NSAyMDUuMjk1IDE4Mi41MDAgMjA1Ljc1MCBDIDE4NS45MjAgMjA2LjE3MCAxODEuODU5IDIyNC41MDAgMTg1LjI1MCAyMjQuNTAwIEMgMTg5LjIxMyAyMjQuNTAwIDE5Ny4yNTAgMjA1Ljc1MCAxOTcuMjUwIDIwNS43NTAgIi8+PC9nPjwvc3ZnPg==';

var menuIconURI = 'data:image/png;base64,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';
/* ----------------------------------------	*/

/* for MIDI Ebvent */

var mMIDI = null;
var mInputs = null;
var mOutputs = null;
var mOutDev = 0; //Output Device Number

var mCtlbuf = new Array(0x80);
var mNoteOn = new Array(0x80);
var mCC_change_event = false;
var mMIDI_event = false;
var mKey_on_event = false;
var mKey_off_event = false;
var mPBend_event = false;
var mPC_event = false;
var mCC_change_flag = false;
var mKey_on_flag = false;
var mKey_off_flag = false;
var mPC_flag = false;
var mPBend_flag = false;
var mNoteNum = 0;
var mNoteVel = 0; //	var mNoteBuf = 0;

var mPBend = 64;
var mPCn = 0;
/* ================================	*/

var mCount = 0;
var mBeat = 0;
var mDticks = 1;
var mTempo = 120;
var mBaseCount = 4;
var mResolution = 480;
setInterval(function () {
  //		clearInterval(id);　//idをclearIntervalで指定している
  mDticks = mTempo * mResolution / 60000;
  mCount = mCount + mDticks * mBaseCount;
  mBeat = mBeat + mDticks * mBaseCount;

  if (mCount > mResolution * 4) {
    mCount = mCount - mResolution * 4;
  }
}, mBaseCount);
/**
 * Enum for eventl ist parameter values.
 * @readonly
 * @enum {string}
 */

/*const EventList = {
	"key on",
   	"key off",
   	"cc-chg",
   	"p-bend",
	"pg-chg"
};*/

var EventList = {
  KEY_ON: 'key-on',
  KEY_OF: 'key-of',
  CC_CHG: 'cc-chg',
  P_BEND: 'p-bend',
  PG_CHG: 'pg-chg'
};

function success(midiAccess) {
  mMIDI = midiAccess;
  var msg = "Success MIDI!\n";
  var inum = 0,
      onum = 0;

  for (var i = 0; i < 0x80; i++) {
    mCtlbuf[i] = 0;
    mNoteOn[i] = 0;
  }

  if (typeof mMIDI.inputs === "function") {
    mInputs = mMIDI.inputs();
    mOutputs = mMIDI.outputs();
  } else {
    msg += "input Device ";
    var inputIterator = mMIDI.inputs.values();
    mInputs = [];

    for (var o = inputIterator.next(); !o.done; o = inputIterator.next()) {
      mInputs.push(o.value);
      msg += (inum + 1).toString(10);
      msg += ":";
      msg += o.value.name;
      msg += " ";
      inum++;
    }

    if (inum == 0) {
      msg += "Zero\n";
    } else {
      msg += "\n";
    }

    msg += "Output Device ";
    var outputIterator = mMIDI.outputs.values();
    mOutputs = [];

    for (var o = outputIterator.next(); !o.done; o = outputIterator.next()) {
      mOutputs.push(o.value);
      msg += (onum + 1).toString(10);
      msg += ":";
      msg += o.value.name;
      msg += " ";
      onum++;
    }

    if (onum == 0) {
      msg += "Zero\n";
    } else {
      msg += "\n";
    }
  }

  for (var i = 0; i < mInputs.length; i++) {
    mInputs[i].onmidimessage = m_midiin;
  } //		alert( "Success MIDI!\n", msg );


  alert(msg);
  console.log(msg);
}

function failure(error) {
  alert("Failed MIDI!" + error);
}

function m_midiin(event) {
  /* MIDI parse */
  //	console.log(event.data[0]);
  switch (event.data[0] & 0xF0) {
    case 0x80:
      mMIDI_event = true;
      m_noteon(event.data[1], 0);
      break;

    case 0x90:
      mMIDI_event = true;
      m_noteon(event.data[1], event.data[2]);
      break;

    case 0xA0:
      break;

    case 0xB0:
      mMIDI_event = true;
      mCC_change_event = true;
      mCC_change_flag = true;
      mCtlbuf[event.data[1]] = event.data[2];
      break;

    case 0xC0:
      mMIDI_event = true;
      mPC_event = true;
      mPC_flag = true;
      mPCn = event.data[1];
      break;

    case 0xD0:
      break;

    case 0xE0:
      mMIDI_event = true;
      mPBend_event = true;
      mPBend_flag = true;
      mPBend = event.data[2];
      break;
  }
}

function m_noteon(note, vel) {
  mNoteNum = note;
  mNoteVel = vel;

  if (vel > 0) {
    mKey_on_event = true;
    mKey_on_flag = true;
    mNoteOn[mNoteNum] = true;
  } else {
    mKey_off_event = true;
    mKey_off_flag = true;
  }
}

function m_midiout(event, note, vel) {
  var data1 = event & 0xFF;
  var data2 = note & 0x7F;
  var data3 = vel & 0x7F;
  /*	if(mOutputs!=null){
  		for(var i=0; i<mOutputs.length; i++){
  			var l_output=mOutputs[i];
  			if(l_output!=null){
  				l_output.send([data1,data2,data3], 0);
  			}
  		}
  	}
  */

  if (mOutputs != null) {
    if (mOutDev < mOutputs.length) {
      var l_output = mOutputs[mOutDev];

      if (l_output != null) {
        l_output.send([data1, data2, data3], 0);
      }
    }
  }
}

function m_midiout_2byte(event, data) {
  var data1 = event & 0xFF;
  var data2 = data & 0x7F;
  /*	if(mOutputs!=null){
  		for(var i=0; i<mOutputs.length; i++){
  			var l_output=mOutputs[i];
  			if(l_output!=null){
  				l_output.send([data1,data2], 0);
  			}
  		}
  	}
  */

  if (mOutputs != null) {
    if (mOutDev < mOutputs.length) {
      var l_output = mOutputs[mOutDev];

      if (l_output != null) {
        l_output.send([data1, data2], 0);
      }
    }
  }
}

function m_sysexout(data, size) {
  var buf = new Array(size);

  for (var i = 0; i < size; i++) {
    buf[i] = data[i];
  }

  if (mOutputs != null) {
    /*		for(var i=0; i<mOutputs.length; i++){
    			var l_output=mOutputs[i];
    			if(l_output!=null){
    				l_output.send(buf, 0);
    			}
    		}
    */
    if (mOutDev < mOutputs.length) {
      var l_output = mOutputs[mOutDev];

      if (l_output != null) {
        l_output.send(buf, 0);
      }
    }
  }
}
/**
 * Class for the new blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */


var Scratch3WebMIDI = /*#__PURE__*/function () {
  function Scratch3WebMIDI(runtime) {
    classCallCheck(this, Scratch3WebMIDI);

    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    navigator.requestMIDIAccess({
      sysex: true
    }).then(success, failure); //this._onTargetCreated = this._onTargetCreated.bind(this);
    //this.runtime.on('targetWasCreated', this._onTargetCreated);
  }
  /*
  	success(midiAccess)
  	{
  		this.m=midiAccess;
  
  		if (typeof this.m.inputs === "function") {
  			this.mInputs  =	this.m.inputs();
  			this.mOutputs =	this.m.outputs();
  		} else {
  			var inputIterator = this.m.inputs.values();
  			this.mInputs = [];
  			for (var o = inputIterator.next(); !o.done; o = inputIterator.next()) {
  				this.mInputs.push(o.value);
  			}
  
  			var outputIterator = this.m.outputs.values();
  			this.mOutputs = [];
  			for (var o = outputIterator.next(); !o.done; o = outputIterator.next()) {
  				this.mOutputs.push(o.value)
  			}
  		}
  		for(var i=0; i<mInputs.length;i++){
  			this.mInputs[i].onmidimessage=this.m_midiin;
  		}
  		alert( "Success MIDI!" );
  	}
  
  	failure(error)
  	{
  		alert( "Failed MIDI!" + error );
  	}
  */

  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  createClass(Scratch3WebMIDI, [{
    key: "getInfo",
    value: function getInfo() {
      return {
        id: 'webmidi',
        //			name: 'Web MIDI for Scratch3',
        name: formatMessage({
          id: 'Web MIDI for Scratch3',
          default: 'Web MIDI',
          description: 'Label for the web midi extension category'
        }),
        menuIconURI: menuIconURI,
        blockIconURI: blockIconURI,
        blocks: [{
          opcode: 's_Note',
          text: 'NoteNum',
          blockType: BlockType.REPORTER
        }, {
          opcode: 's_Vel',
          text: 'Velocity',
          blockType: BlockType.REPORTER
        }, {
          opcode: 's_PBend',
          text: 'PB',
          blockType: BlockType.REPORTER
        }, {
          opcode: 's_PChange',
          text: 'PC',
          blockType: BlockType.REPORTER
        }, {
          opcode: 's_Ticks',
          text: 'Ticks',
          blockType: BlockType.REPORTER
        }, {
          opcode: 's_Ccin',
          text: formatMessage({
            id: 'webmidi.s_Ccin',
            default: 'CC [ccnum]',
            description: 'Control Change Value'
          }),
          blockType: BlockType.REPORTER,
          arguments: {
            ccnum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 's_Getmidievent',
          text: 'MIDI EVENT',
          blockType: BlockType.HAT
        }, {
          opcode: 's_Getkeyon',
          text: 'Key ON',
          blockType: BlockType.HAT
        }, {
          opcode: 's_Getkeyoff',
          text: 'Key OFF',
          blockType: BlockType.HAT
        }, {
          opcode: 's_PBevent',
          text: 'P.Bend',
          blockType: BlockType.HAT
        }, {
          opcode: 's_PCevent',
          text: 'PrgChg',
          blockType: BlockType.HAT
        }, {
          opcode: 's_Getcc',
          text: 'CtrlChg',
          blockType: BlockType.HAT
        }, {
          opcode: 's_Getkeyonnum',
          text: formatMessage({
            id: 'webmidi.s_Getkeyonnum',
            default: 'KEY ON [ckeynum]',
            description: 'Note Number'
          }),
          blockType: BlockType.HAT,
          arguments: {
            ckeynum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 's_Event',
          text: formatMessage({
            id: 'webmidi.s_Event',
            default: 'EVENT [n_event]',
            description: 'any events recieved?'
          }),
          blockType: BlockType.BOOLEAN,
          arguments: {
            n_event: {
              type: ArgumentType.STRING,
              menu: 'eventlist',
              defaultValue: EventList.KEY_ON
            }
          }
        }, {
          opcode: 's_Noteon_out',
          text: formatMessage({
            id: 'webmidi.noteon_out',
            default: 'NOTE ON [channelnum][notenum][velo]',
            description: 'send note on'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            channelnum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            notenum: {
              type: ArgumentType.NUMBER,
              defaultValue: 60
            },
            velo: {
              type: ArgumentType.NUMBER,
              defaultValue: 127
            }
          }
        }, {
          opcode: 's_Noteon_out_duration',
          text: formatMessage({
            id: 'webmidi.noteon_out_durauion',
            default: 'NOTE ON [channelnum][notenum][velo][duration]',
            description: 'send note on with duration'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            channelnum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            notenum: {
              type: ArgumentType.NUMBER,
              defaultValue: 60
            },
            velo: {
              type: ArgumentType.NUMBER,
              defaultValue: 127
            },
            duration: {
              type: ArgumentType.NUMBER,
              defaultValue: 480
            }
          }
        }, {
          opcode: 's_Noteoff_out',
          text: formatMessage({
            id: 'webmidi.noteoff_out',
            default: 'NOTE OFF [channelnum][notenum][velo]',
            description: 'send note off'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            channelnum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            notenum: {
              type: ArgumentType.NUMBER,
              defaultValue: 60
            },
            velo: {
              type: ArgumentType.NUMBER,
              defaultValue: 127
            }
          }
        }, {
          opcode: 's_ProgramChange',
          text: formatMessage({
            id: 'webmidi.program_change',
            default: 'PrgChg [channelnum][pnumber]',
            description: 'send program change'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            channelnum: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            pnumber: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 's_RestTicks',
          text: formatMessage({
            id: 'webmidi.rest_tickes',
            default: 'Rest [rticks] tickes',
            description: 'rest some tickes'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            rticks: {
              type: ArgumentType.NUMBER,
              defaultValue: 240
            }
          }
        }, {
          opcode: 's_GetBeat',
          text: formatMessage({
            id: 'webmidi.s_GetBeat',
            default: 'BEAT [tempo]',
            description: 'Tempo'
          }),
          blockType: BlockType.HAT,
          arguments: {
            tempo: {
              type: ArgumentType.NUMBER,
              defaultValue: 120
            }
          }
        }, {
          opcode: 's_OutDevice',
          text: formatMessage({
            id: 'webmidi.out_device',
            default: 'Out Dev No. [outdev]',
            description: 'midi out device number'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            outdev: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        },
        /* ================================	*/
        {
          opcode: 's_PokeText',
          text: formatMessage({
            id: 'webmidi.s_poketext',
            default: 'Pokemiku [rtext]',
            description: 'send text to Pokemiku'
          }),
          blockType: BlockType.COMMAND,
          arguments: {
            rtext: {
              type: ArgumentType.STRING,
              defaultValue: 'あいうえお'
            }
          }
        }, {
          opcode: 's_Strlen',
          text: 'Strlen',
          blockType: BlockType.REPORTER
        }
        /* ================================	*/
        ],
        menus: {
          eventlist: {
            acceptReporters: true,
            items: this._initEventList()
          }
        }
      };
    }
    /* ================================	*/

    /**
      * Initialize event parameters menu with localized strings
      * @returns {array} of the localized text and values for each menu element
      * @private
      */

  }, {
    key: "_initEventList",
    value: function _initEventList() {
      return [{
        text: formatMessage({
          id: 'webmidi.eventlist.key-on',
          default: 'key-on',
          description: 'label for event for webmidi extension'
        }),
        value: EventList.KEY_ON
      }, {
        text: formatMessage({
          id: 'webmidi.eventlist.key-of',
          default: 'key-of',
          description: 'label for event for webmidi extension'
        }),
        value: EventList.KEY_OF
      }, {
        text: formatMessage({
          id: 'webmidi.eventlist.cc-chg',
          default: 'cc-chg',
          description: 'label for event for webmidi extension'
        }),
        value: EventList.CC_CHG
      }, {
        text: formatMessage({
          id: 'webmidi.eventlist.p-bend',
          default: 'p-bend',
          description: 'label for event for webmidi extension'
        }),
        value: EventList.P_BEND
      }, {
        text: formatMessage({
          id: 'webmidi.eventlist.pg-chg',
          default: 'pg-chg',
          description: 'label for event for webmidi extension'
        }),
        value: EventList.PG_CHG
      }];
    }
    /* ================================	*/

    /**
    	* Write log.
    	* @param {object} args - the block arguments.
    	* @property {number} TEXT - the text.
    */

  }, {
    key: "writeLog",
    value: function writeLog(args) {
      var text = Cast.toString(args.TEXT);
      log.log(text);
    }
    /**
    	* Get the browser.
    	* @return {number} - the user agent.
    */

  }, {
    key: "getBrowser",
    value: function getBrowser() {
      return navigator.userAgent;
    }
    /* ================================	*/
    // GET NOTE ON/OFF

  }, {
    key: "s_Getmidievent",
    value: function s_Getmidievent() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mMIDI_event == true) {
        mMIDI_event = false;
        return true;
      }

      return false;
    } //Set Note Number

  }, {
    key: "s_Note",
    value: function s_Note() {
      return mNoteNum;
    } //Set Note Vel

  }, {
    key: "s_Vel",
    value: function s_Vel() {
      return mNoteVel;
    } // GET KEY ON

  }, {
    key: "s_Getkeyon",
    value: function s_Getkeyon() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mKey_on_event == true) {
        mKey_on_event = false;
        return true;
      }

      return false;
    } // GET KEY ON with keynumber

  }, {
    key: "s_Getkeyonnum",
    value: function s_Getkeyonnum(args) {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mNoteOn[args.ckeynum] == true) {
        mNoteOn[args.ckeynum] = false;
        return true;
      }

      return false;
    } // GET KEY OFF

  }, {
    key: "s_Getkeyoff",
    value: function s_Getkeyoff() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mKey_off_event == true) {
        mKey_off_event = false;
        return true;
      }

      return false;
    }
    /* ================================	*/
    // GET CC

  }, {
    key: "s_Getcc",
    value: function s_Getcc() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mCC_change_event === true) {
        mCC_change_event = false;
        return true;
      }

      return false;
    } // Set CC Value
    // ccnum: Control Change Number

  }, {
    key: "s_Ccin",
    value: function s_Ccin(args) {
      return mCtlbuf[args.ccnum];
    }
    /* ================================	*/
    //Set PitchBend

  }, {
    key: "s_PBevent",
    value: function s_PBevent() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mPBend_event == true) {
        mPBend_event = false;
        return true;
      }

      return false;
    } //Set PitchBend Valuel

  }, {
    key: "s_PBend",
    value: function s_PBend() {
      return mPBend;
    }
    /* ================================	*/
    //Set Program Change Event

  }, {
    key: "s_PCevent",
    value: function s_PCevent() {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      if (mPC_event == true) {
        mPC_event = false;
        return true;
      }

      return false;
    } //Set Program Change

  }, {
    key: "s_PChange",
    value: function s_PChange() {
      return mPCn;
    }
    /* ================================	*/
    //Event

  }, {
    key: "s_Event",
    value: function s_Event(args) {
      var n_flag = false;

      switch (args.n_event) {
        case EventList.KEY_ON:
          {
            if (mKey_on_flag == true) {
              n_flag = true;
              mKey_on_flag = false;
            }
          }
          break;

        case EventList.KEY_OF:
          {
            if (mKey_off_flag == true) {
              n_flag = true;
              mKey_off_flag = false;
            }
          }
          break;

        case EventList.CC_CHG:
          {
            if (mCC_change_flag == true) {
              n_flag = true;
              mCC_change_flag = false;
            }
          }
          break;

        case EventList.P_BEND:
          {
            if (mPBend_flag == true) {
              n_flag = true;
              mPBend_flag = false;
            }
          }
          break;

        case EventList.PG_CHG:
          {
            if (mPC_flag == true) {
              n_flag = true;
              mPC_flag = false;
            }
          }
          break;
      }

      return n_flag;
    }
    /* ================================	*/
    //NOTE ON

  }, {
    key: "s_Noteon_out",
    value: function s_Noteon_out(args) {
      var chnum = (args.channelnum & 0x0F) - 1;
      return m_midiout(0x90 + chnum, args.notenum & 0x7F, args.velo & 0x7F);
    }
  }, {
    key: "s_Noteon_out_duration",
    value: function s_Noteon_out_duration(args) {
      var chnum = (args.channelnum & 0x0F) - 1;
      var irticks = args.duration;
      if (irticks < 10) irticks = 10;
      var waittime = irticks / mResolution * 60 / mTempo * 1000;
      setTimeout(function () {
        m_midiout(0x80 + chnum, args.notenum & 0x7F, 0x40);
      }, waittime);
      return m_midiout(0x90 + chnum, args.notenum & 0x7F, args.velo & 0x7F);
    } //NOTE OFF

  }, {
    key: "s_Noteoff_out",
    value: function s_Noteoff_out(args) {
      var chnum = (args.channelnum & 0x0F) - 1;
      return m_midiout(0x80 + chnum, args.notenum & 0x7F, args.velo & 0x7F);
    } //Program Change

  }, {
    key: "s_ProgramChange",
    value: function s_ProgramChange(args) {
      var chnum = (args.channelnum & 0x0F) - 1;
      var pgnum = args.pnumber & 0x7F;
      return m_midiout_2byte(0xC0 + chnum, pgnum);
    } //MIDI Output Device Number

  }, {
    key: "s_OutDevice",
    value: function s_OutDevice(args) {
      if (args.outdev < 1) args.outdev = 1;else if (args.outdev > mOutputs.length) args.outdev = mOutputs.length;
      mOutDev = args.outdev - 1;
    }
    /* ================================	*/

    /*var mCount = 0;
    var mTimer = setInterval(function(){
    //		clearInterval(id);　//idをclearIntervalで指定している
    		mCount++;
    	}, 20);
    */
    // Beat

  }, {
    key: "s_GetBeat",
    value: function s_GetBeat(args) {
      // Reset alarm_went_off if it is true, and return true
      // otherwise, return false.
      mTempo = args.tempo;

      if (mBeat >= mResolution) {
        mBeat = mBeat - mResolution;
        return true;
      }

      return false;
    }
  }, {
    key: "s_Ticks",
    value: function s_Ticks() {
      return Math.floor(mCount);
    }
  }, {
    key: "s_PokeText",
    value: function s_PokeText(args) {
      if (args.rtext.length <= 32) {
        //		console.log(args.rtext);
        mSize = sendstring(args.rtext);
        mSysSz = set_sysex();
        m_sysexout(mMKsys, mSysSz);
      }
    }
  }, {
    key: "s_Strlen",
    value: function s_Strlen() {
      return mSize;
    }
    /*
    	s_RestTicks(args){
    		args.rticks = args.rticks%480;
    		var irticks = args.rticks;
    		var iCount = mCount;
    
    		var itimer = setInterval(function(){
    			var dcount = mCount-iCount;
    			if ( dcount<0 ) dcount =dcount + mResolution*4;
    			if( dcount >= irticks){
    //				console.log(irticks,dcount);
    				clearInterval(itimer);
    				return true;
    			}
    	       return false;
    
    		} , mBaseCount);
    
    	}
    */

    /**
     * Rest for some number of beats.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     * @property {number} BEATS - the duration in beats of the rest.
     */

  }, {
    key: "s_RestTicks",
    value: function s_RestTicks(args, util) {
      this.mCount;

      if (this._stackTimerNeedsInit(util)) {
        var irticks = args.rticks;
        var waittime = irticks / mResolution * 60 / mTempo; //         beats = this._clampBeats(beats);
        //         this._startStackTimer(util, this._beatsToSec(beats));

        this._startStackTimer(util, waittime);
      } else {
        this._checkStackTimer(util);
      }
    }
    /* ================================	*/

    /**
     * Check if the stack timer needs initialization.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean} - true if the stack timer needs to be initialized.
     * @private
     */

  }, {
    key: "_stackTimerNeedsInit",
    value: function _stackTimerNeedsInit(util) {
      return !util.stackFrame.timer;
    }
    /**
     * Start the stack timer and the yield the thread if necessary.
     * @param {object} util - utility object provided by the runtime.
     * @param {number} duration - a duration in seconds to set the timer for.
     * @private
     */

  }, {
    key: "_startStackTimer",
    value: function _startStackTimer(util, duration) {
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = duration;
      util.yield();
    }
    /**
     * Check the stack timer, and if its time is not up yet, yield the thread.
     * @param {object} util - utility object provided by the runtime.
     * @private
     */

  }, {
    key: "_checkStackTimer",
    value: function _checkStackTimer(util) {
      var timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 1000) {
        util.yield();
      }
    }
    /* ================================	*/

  }]);

  return Scratch3WebMIDI;
}(); //--- class Scratch3WebMIDI


var blockClass = Scratch3WebMIDI;
/* ================================	*/

var textMapANum = 73;
var textMapBNum = 72;
var textMapA = [//textMapANum
["あ", "a"], ["い", "i"], ["う", "M"], ["え", "e"], ["お", "o"], ["か", "k a"], ["き", "k' i"], ["く", "k M"], ["け", "k e"], ["こ", "k o"], ["さ", "s a"], ["し", "S i"], ["す", "s M"], ["せ", "s e"], ["そ", "s o"], ["た", "t a"], ["ち", "tS i"], ["つ", "ts M"], ["て", "t e"], ["と", "t o"], ["な", "n a"], ["に", "J i"], ["ぬ", "n M"], ["ね", "n e"], ["の", "n o"], ["は", "h a"], ["ひ", "C i"], ["ふ", "p\\ M"], ["へ", "h e"], ["ほ", "h o"], ["ま", "m a"], ["み", "m i"], ["む", "m M"], ["め", "m e"], ["も", "m o"], ["ら", "4 a"], ["り", "4' i"], ["る", "4 M"], ["れ", "4 e"], ["ろ", "4 o"], ["が", "g a"], ["ぎ", "g' i"], ["ぐ", "g M"], ["げ", "g e"], ["ご", "g o"], ["ざ", "dz a"], ["じ", "dZ i"], ["ず", "dz M"], ["ぜ", "dZ e"], ["ぞ", "dz o"], ["だ", "d a"], ["ぢ", "dZ i"], ["づ", "dz M"], ["で", "d e"], ["ど", "d o"], ["ば", "b a"], ["び", "b' i"], ["ぶ", "b M"], ["べ", "b e"], ["ぼ", "b o"], ["ぱ", "p a"], ["ぴ", "p' i"], ["ぷ", "p M"], ["ぺ", "p e"], ["ぽ", "p o"], ["や", "j a"], ["ゆ", "j M"], ["よ", "j o"], ["わ", "w a"], ["ゐ", "w i"], ["ゑ", "w e"], ["を", "o"], ["ん", "N\\"]];
var textMapB = [//textMapBNum
["ふぁ", "p\\ a"], ["つぁ", "ts a"], ["うぃ", "w i"], ["すぃ", "s i"], ["ずぃ", "dz i"], ["つぃ", "ts i"], ["てぃ", "t' i"], ["でぃ", "d' i"], ["ふぃ", "p\\' i"], ["とぅ", "t M"], ["どぅ", "d M"], ["いぇ", "j e"], ["うぇ", "w e"], ["きぇ", "k' e"], ["しぇ", "S e"], ["ちぇ", "tS e"], ["つぇ", "ts e"], ["てぇ", "t' e"], ["にぇ", "J e"], ["ひぇ", "C e"], ["みぇ", "m' e"], ["りぇ", "4' e"], ["ぎぇ", "g' e"], ["じぇ", "dZ e"], ["でぇ", "d' e"], ["びぇ", "b' e"], ["ぴぇ", "p' e"], ["ふぇ", "p\\ e"], ["うぉ", "w o"], ["つぉ", "ts o"], ["ふぉ", "p\\ o"], ["きゃ", "k' a"], ["しゃ", "S a"], ["ちゃ", "tS a"], ["てゃ", "t' a"], ["にゃ", "J a"], ["ひゃ", "C a"], ["みゃ", "m' a"], ["りゃ", "4' a"], ["ぎゃ", "N' a"], ["じゃ", "dZ a"], ["でゃ", "d' a"], ["びゃ", "b' a"], ["ぴゃ", "p' a"], ["ふゃ", "p\\' a"], ["きゅ", "k' M"], ["しゅ", "S M"], ["ちゅ", "tS M"], ["てゅ", "t' M"], ["にゅ", "J M"], ["ひゅ", "C M"], ["みゅ", "m' M"], ["りゅ", "4' M"], ["ぎゅ", "g' M"], ["じゅ", "dZ M"], ["でゅ", "d' M"], ["びゅ", "b' M"], ["ぴゅ", "p' M"], ["ふゅ", "p\\' M"], ["きょ", "k' o"], ["しょ", "S o"], ["ちょ", "tS o"], ["てょ", "t' o"], ["にょ", "J o"], ["ひょ", "C o"], ["みょ", "m' o"], ["りょ", "4' o"], ["ぎょ", "N' o"], ["じょ", "dZ o"], ["でょ", "d' o"], ["びょ", "b' o"], ["ぴょ", "p' o"]];
var mDex;
var mTextMap = null;
var mMKsys = null;
var mSize = 0;
var mSysSz = null;
var mSYSMAX = 1024;

function init_textanlz() {
  mTextMap = new Array(textMapANum + textMapBNum);

  for (var i = 0; i < textMapANum; i++) {
    mTextMap[textMapA[i][0]] = textMapA[i][1];
  }

  for (var i = 0; i < textMapBNum; i++) {
    mTextMap[textMapB[i][0]] = textMapB[i][1];
  }

  mMKsys = new Array(mSYSMAX);
  mMKsys[0] = 0xF0;
  mMKsys[1] = 0x43;
  mMKsys[2] = 0x79;
  mMKsys[3] = 0x09;
  mMKsys[4] = 0x00;
  mMKsys[5] = 0x50;
  mMKsys[6] = 0x10;
}

function sendstring(text) {
  var i,
      j = text.length,
      k = 0;
  var str = null;
  var ss = null;
  mDex = new Array(j);

  for (i = 0; i < j - 1; i++) {
    str = text[i] + text[i + 1];

    if ((ss = mTextMap[str]) != null) {
      mDex[k++] = ss;
      i++;
    } else {
      if ((ss = mTextMap[text[i]]) != null) {
        mDex[k++] = ss;
      }
    }
  }

  if (i < j) {
    if ((ss = mTextMap[text[i]]) != null) {
      mDex[k++] = ss;
    }
  }

  return k;
}

function set_sysex() {
  var i, j;
  var k = 7;

  for (i = 0; i < mSize; i++) {
    for (j = 0; j < mDex[i].length; j++) {
      mMKsys[k++] = mDex[i].charCodeAt(j);
    }

    if (i < mSize - 1) mMKsys[k++] = 0x2c;
  }

  mMKsys[k++] = 0x00;
  mMKsys[k++] = 0xF7;
  return k;
}

init_textanlz();

export { blockClass, entry };
